# Using Variables in Lambda

# Working with Built-In Functional Interfaces
## Implementing Supplier
## Implementing Consumer and BiConsumer
## Implementing Predicate and BiPredicate
## Implementing Function and BiFunction
## Implementing UnaryOperator and BinaryOperator
## Checking Functional Interfaces

# Returning an Optional

# Using Streams
## Creating Stream Sources
## Using Common Terminal Operations
### count()
### min() and max()
### findAny() and findFirst()
### allMatch(), anyMatch() and noneMatch()
### forEach()
### reduce()
### collect()
## Using Common Intermediate Operations
### filter()
### distict()
### limit() and skip()
### map()
### flatMap()
### sorted()
### peek()
## Putting Together the Pipeline
## Printing a Stream

# Working with Primitives
## Creating Primitive Streams
## Using Optional with Primitive Streams
## Summararizing Statistics
## Learning the Functional Interfaces for Primitives
### Functional Interfaces for boolean
### Functional Interfaces for double, int and long

# Working with Advanced Stream Pipeline Concepts
## Linking Streams to the Underlying Data
## Chaining Optional 
## Collecting Results
### Collecting Using Basic Collectors 
### Collecting into Maps
### Collecting Using Grouping, Partitioning and Mapping 
